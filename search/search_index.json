{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Active Matter DEM Simulator","text":"<p>This is a versatile classical particle dynamics simulation code that focuses on numerically modelling particulate systems/ granular matter. The system can be anything ranging from materials like colloids, grains to active and living systems like cellular assemblies.  This code incorporates Discrete-Element-Method (DEM) simulation techniques <sup>2</sup> for application to both passive and active granular matter.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>Simulates a diverse range of physical systems including colloids, cellular assemblies, spinners etc.</li> <li>Availability of various integration schemes (Velocity-Verlet, Leimkuhler-Matthews etc.) and force calculation   algorithms.</li> <li>Realistic Contact force models predefined.</li> <li>Customizable and extendable codebase for specific research needs.</li> <li>Easy to use</li> </ul>"},{"location":"#organization-of-this-documentaion","title":"Organization of this documentaion","text":"<p>This documentation is organized into the following parts:</p> <ol> <li>The Physics Guide with information about general physics that goes behind this simulation code.</li> <li>The Programmer Guide with information about code structure: header files and methods.</li> <li>The Hands-on examples with some working examples to illustrate the use of this code.</li> </ol> <p>Organization of this material is simple and as readable as it can be.</p>"},{"location":"#gallery","title":"Gallery","text":"<p>The following examples depict the cases where this simulation code was used to reproduce results from the literature of  Active matter and Granular matter physics.</p>  Motility Induced Phase Separation (Cates, M. E., &amp; Tailleur, J. (2015). \"Motility-induced phase separation.\")   Directed percolation [1, see footnote] (Grober et al. \"Unconventional colloidal aggregation in chiral bacterial baths.\" Nature Physics).    Phase-separation in Chiral Lennard-Jones Fluid (Claudio B. Caporusso, et al. \"Phase Coexistence and Edge Currents in the Chiral Lennard-Jones Fluid\"). Confined gas of active spinners (Tsai, J-C., et al. \"A chiral granular gas\"). <ol> <li> <p>Pabitra Masanta worked on this for his master's thesis work at IIT Bombay\u00a0\u21a9</p> </li> <li> <p>H P\ua3ac Zhu, Zongyan Y Zhou, RY Yang, and AB Yu. Discrete particle simulation of particulate systems: theoretical developments. Chemical engineering science, 62(13):3378\u20133396, 2007.\u00a0\u21a9</p> </li> </ol>"},{"location":"index_2/","title":"How to get this code","text":"<p>Requirements: C++ compiler, Git</p> <p>This code does not require any other special dependencies.</p>"},{"location":"index_2/#clone-this-project-from-githubcom","title":"Clone this project from Github.com","text":"<p>Following these steps will help you clone this project in your local directory:</p> <ul> <li> <p>Navigate to the main page of the repository on Github.com, whose link is available at the top right corner of this website.</p> </li> <li> <p>Above the list of files, click &lt; &gt; Code. </p> </li> </ul> <ul> <li> <p>Copy the URL for the repository.</p> <ul> <li>To clone the repository using HTTPS, under \"HTTPS\", click copy</li> <li>To clone the repository using an SSH key, including a certificate issued by your organization's SSH certificate authority, click SSH, then click copy</li> <li>To clone a repository using GitHub CLI, click GitHub CLI, then click copy      </li> </ul> </li> <li> <p>Open Terminal.</p> </li> <li>Change the current working directory to the location where you want the cloned directory.</li> <li>Type <code>git clone</code>, and then paste the URL you copied earlier. <pre><code>git clone https://github.com/vishu-byte/Active-Matter-DEM-Simulation.git\n</code></pre></li> <li>Press Enter to create your local clone.</li> </ul> <p>This should create your local clone, you can now use the code for your own project.</p>"},{"location":"General_Physics/Overview/","title":"What physical systems we can simulate?","text":"<p>A typical system would be a collection of large numbers of soft or hard spheres that can interact with each other via repulsion or attraction and contact forces (e.g frictional forces) These entities have transational as well as rotational degrees of freedom. Therefore, dynamical equations will involve the evolution of both kinds of degrees of freedom.</p>"},{"location":"General_Physics/Overview/#equations-of-motion","title":"Equations of motion","text":"<p>Given the sum of forces \\(\\mathbf{f_{i}}\\) on a particle \\(i\\) (\\(\\mathbf{f_{i}}\\)  can be from other particles, from walls or any potential), the problem in hand is to integrate the Newton's equations of motions for the translational and rotational degrees of freedom:</p> \\[ m_{i}\\frac{d^{2}\\mathbf{{r_{i}}}}{dt^{2}} = \\mathbf{f_{i}} + \\mathbf{f^{\\text{medium}}} + \\mathbf{f^{active}_{i}} \\] \\[ I_{i}\\frac{d\\mathbf{{\\omega_{i}}}}{dt} = \\mathbf{\\Gamma _{i}} + \\mathbf{\\Gamma ^{\\text{medium}}} +  \\mathbf{\\Gamma ^{active} _{i}} \\] <p>where \\(m_{i}, I_{i}\\) are masses and momentum of inertia of \\(i^{th}\\) particle, whose center of mass is at \\(\\mathbf{r_{i}}\\). (\\(\\mathbf{f_{i}}, \\mathbf{\\Gamma _{i}}\\)) are the forces and torques on \\(i^{th}\\) particle from other particles or walls. There can also be intrinsic translational and rotational active forces and torques (\\(\\mathbf{f^{active}_{i}},\\mathbf{\\Gamma ^{active} _{i}}\\)).Finally, there are forces due to medium (\\(\\mathbf{f^{\\text{medium}}},\\mathbf{\\Gamma ^{\\text{medium}}}\\)). In addition to these, there can be noise in the system such as due to a thermal bath in which case we need to integrate Langevin equations.</p> <p>We can integrate these dynamical equations using tools from numerical integration as thoroughly described in the books <sup>1</sup><sup>2</sup><sup>3</sup> Specifically, we have borrowed the following integration schemes from these books</p> <ol> <li>Euler integration</li> <li>Verlet integration: Leap-Frog, Velocity Verlet</li> <li>BAOAB algorithm of Leimkuhler and Matthews. (for Langevin Dynamics)</li> </ol> <p>The typically short-ranged interactions in granular media allow for optimization by using linked-cell (LC) or alternative methods in order to make the neighborhood search more efficient.</p>"},{"location":"General_Physics/Overview/#contact-force-models","title":"Contact force models","text":"Contact-force model <p>The realistic and detailed modeling of the deformations of particles in contact with each other is much too complicated; therefore, we relate the interaction force to the overlap \\(\\delta\\) of the two particles.<sup>4</sup></p> <p>The force on particle \\(i\\), from particle \\(j\\), at contact point p, can be decomposed into a radial/central and a tangential part :</p> \\[ \\mathbf{f_{ij}} = f_{ij}^{c}\\mathbf{n}  + f_{ij}^{t}\\mathbf{t} \\] <p>where \\(\\mathbf{n.t} = 0\\). The tangential force leads to a torque.</p>"},{"location":"General_Physics/Overview/#radialcentral-interaction","title":"Radial/Central interaction","text":"<p>As typically, interactions involved are repulsive. These can be modeled in two ways</p> <p>Spring-like force: </p> <p>This is for modeling soft-repulsion between spheres.</p> \\[ f_{ij}^{c} = \\frac{1}{2}k|\\mathbf{r_{i}} - \\mathbf{r_{j}}|^{2} \\] <p>Generalized Weeks-Chandler-Andersen (WCA) potential:</p> <p>This is for modeling hard interaction.</p> \\[ U(r)= 4\\epsilon \\left[ (\\frac{\\sigma}{r})^{2l} - (\\frac{\\sigma}{r})^{l} \\right]  + \\epsilon ,  \\ \\ \\text{for} \\ \\ r\\leq 2^{1/6}\\sigma \\\\      = 0, \\ \\ \\text{for} \\ \\  r &gt; 2^{1/6}\\sigma \\] \\[ f_{ij}^{c} = -\\frac{dU(r)}{dr}\\hat{\\mathbf{{r_{ij}}}} \\] <p>where \\(\\epsilon\\) sets the interaction energy scale and \\(l\\) is the potential stiffness.</p> <p>Details about WCA interaction are in <sup>5</sup>.</p>"},{"location":"General_Physics/Overview/#tangential-interaction","title":"Tangential interaction","text":"\\[ \\mathbf{f_{ij}^{t}} =   \\mu(\\boldsymbol{\\Omega_{ij}}\\times \\mathbf{r_{ij}}) \\] <p>\\(\\boldsymbol{\\Omega_{ij}} = \\hat{\\mathbf{z}}(\\omega_{i} + \\omega_{j})/2\\) is average rotation speed of a pair of particles.</p> <p>Other models for tangential or central forces can be found in <sup>4</sup>.</p> <ol> <li> <p>Michael P Allen and Dominic J Tildesley. Computer simulation of liquids. Oxford university press, 2017.\u00a0\u21a9</p> </li> <li> <p>Dennis C Rapaport. The art of molecular dynamics simulation. Cambridge university press, 2004.\u00a0\u21a9</p> </li> <li> <p>Thorsten P\u00f6schel and Thomas Schwager. Computational granular dynamics: models and algorithms. Springer Science &amp; Business Media, 2005.\u00a0\u21a9</p> </li> <li> <p>Stefan Luding. Cohesive, frictional powders: contact models for tension. Granular matter, 10(4):235\u2013246, 2008.\u00a0\u21a9\u21a9</p> </li> <li> <p>John D Weeks, David Chandler, and Hans C Andersen. Role of repulsive forces in determining the equilibrium structure of simple liquids. The Journal of chemical physics, 54(12):5237\u20135247, 1971.\u00a0\u21a9</p> </li> </ol>"},{"location":"Last/Contributing/","title":"Contributing","text":""},{"location":"Last/Contributing/#how-you-can-contribute","title":"How you can contribute","text":"<p>xsfdgs</p>"},{"location":"Last/Details/","title":"License and contributing","text":""},{"location":"Last/Details/#license","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Vishu Saini</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"Last/Details/#how-you-can-contribute","title":"How you can contribute","text":"<p>This simulator is an actively maintained and constantly evolving project that aims to serve diverse applications. You can contribute by making a pull request that will be reviewed and integrated into the main repository when the changes made are approved. You can contribute bug fixes, changes to the documentation, or new functionality you have developed.</p> <p>If you have any ideas about this simulator's improvements or would like to contribute to the project, do not hesitate to contact the author:</p> <p>Vishu Saini </p> <p>Contact: vishusaini220301@gmail.com</p>"},{"location":"Programmer_Guide/Overview/","title":"Introduction","text":""},{"location":"Programmer_Guide/Overview/#object-oriented-c","title":"Object-oriented C++","text":"<p>Particle systems inherently have a basic object-oriented flavor. Therefore, we have implemented a simple object-oriented particle system in C++ which is kept as general as possible so that it can be applied to a variety of applications.</p> <p>Furthermore, particle systems have many features that make them well suited for solutions on high-performance computers. For example, we can usually allocate groups of particles to processors in a straight-forward manner. We usually distribute the force (behavior) calculation among processors. <sup>1</sup></p> <p>We decided to build a simple base particle system using the object-oriented features of C++ and then use it to develop code for some of the applications that have been used successfully tested.</p> <p>Particles In object-oriented terms, particles are objects with a set of attributes and methods. Particles are handled using class<code>Particles</code></p> <p>Particle System A particle system is a collection of discrete entities called particles. Each particle is described by its state and a collection of attributes. We implement the concept of a particle system with class <code>ParticleSystem</code></p> <p>We can evolve this particle system with time, (according to some dynamical equations like Newton's equations) by looping  through the following steps:</p> <ol> <li>Accumulate the forces on each particle: This is carried out using force calculators, which are methods of class <code>Physics</code></li> <li>Step forward one time step using a standard differential equation solver:  This is carried out using various integrators, which are methods of class <code>Physics</code></li> <li>If desired, write the state of particle system to a file (for analysis or rendering)</li> </ol> <p>The force accumulation step is the most time consuming part of the process and whatcharacterizes a particular application. Generally, there are three types of forces <sup>1</sup></p> <ol> <li>unary forces in which the force on each particle does not depend on other particles </li> <li>k-ary forces in which the force on a particle depends on a small set of up to k other particles,</li> <li>n-ary forces where each the force on each particle can depend on all other particles. </li> </ol> <p>Once force accumulation is complete, we compute the state of all particles at the next time step, which is usually done by using a standard ordinary differential equation solver. Depending on the order of the solver, multiple force accumulations may be required for each time step.</p> <p>Our aim was to build a flexible software system that can support a multitude of applications by allowing for different force accumulators, different numerical methods, including the ability to parallelize the code.</p>"},{"location":"Programmer_Guide/Overview/#organization","title":"Organization","text":"<p>Our code is organized into the following key sections.</p>"},{"location":"Programmer_Guide/Overview/#particle-system","title":"Particle System","text":"<p>Particle system creation is handled by classes <code>Particles</code> and <code>ParticleSystem</code></p>"},{"location":"Programmer_Guide/Overview/#physics","title":"Physics","text":"<p>The physics of the simulation is handled by classes <code>Physics</code>, <code>Langevin_Dynamics</code></p>"},{"location":"Programmer_Guide/Overview/#graphical-rendition","title":"Graphical Rendition","text":"<p>This code is used to generate particle attributes with time. To graphically render such a state, one must write the state of the particle system to a ouput file (eg. .xyz) that can be rendered in visualization frameworks like Ovito.</p> <ol> <li> <p>Jun Zhang et al. An object-oriented particle system for simulation and visualization. URL: https://www.researchgate.net/profile/P-Alsing/publication/245349101_An_Object-Oriented_Particle_System_for_Simulation_and_Visualization/links/53dfa1a20cf2a768e49bb8cf/An-Object-Oriented-Particle-System-for-Simulation-and-Visualization.pdf (visited on visited on 2023 September).\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"Programmer_Guide/Graphical_rendition/Overview/","title":"Overview","text":""},{"location":"Programmer_Guide/Graphical_rendition/Overview/#graphical-rendition","title":"Graphical Rendition","text":"<p>This code is used to generate particle attributes with time. To graphically render such a state, one must write the state of the particle system to a ouput file (eg. .xyz) that can be rendered in visualization frameworks like Ovito.</p>"},{"location":"Programmer_Guide/ParticleSystem/Overview/","title":"Overview","text":""},{"location":"Programmer_Guide/ParticleSystem/Overview/#system-of-particles","title":"System of Particles","text":"<p>A particle system is a collection of discrete entities called particles. Each particle is described by its state and a collection of attributes. We implement the concept of a particle system with classes: <code>Particles</code> and <code>ParticleSystem</code></p>"},{"location":"Programmer_Guide/ParticleSystem/Class%3AParticleSystem/Description/","title":"Class: ParticleSystem","text":""},{"location":"Programmer_Guide/ParticleSystem/Class%3AParticleSystem/Description/#introduction","title":"Introduction","text":"<p>This class handles creation of a particle System of particle objects.</p> <p>The particle system is an instance of the class <code>ParSim::ParticleSystem</code>. A <code>ParticleSystem</code> object basically represents our particle system each entity of which is a <code>Particle</code> object. </p> <p><code>ParticleSystem</code> has an array of <code>Particle</code> objects created on heap.</p> Attributes Description <code>Particle *particle_array</code> An array of <code>Particle</code> objects <p>Other attributes are total number of particles in a system, size etc.</p> Attributes Description <code>int no_of_particles</code> Total number of particles in the system <code>double L</code> Size of the system \\(L\\) <code>double phi</code> Area density of the system \\(\\phi\\) <p>\\(L\\) and \\(\\phi\\) will be ofcourse related.</p>"},{"location":"Programmer_Guide/ParticleSystem/Class%3AParticleSystem/Description/#intialization","title":"Intialization","text":"<p><pre><code>ParSim::ParticleSystem::ParticleSystem(int N, double omega, double dim)\n</code></pre> Parameterized constructor. Initializes a system of <code>N</code> particles on a lattice grid defined by length <code>dim</code>.  Each particle has <code>omega_activity</code> set to <code>omega</code>.</p> <p>There are other helpful methods that might be needed.</p> <p><pre><code>double ParSim::ParticleSystem::distance(Particle &amp;par1, Particle &amp;par2)\n</code></pre> Calculates distance between two particles <code>par1</code> and <code>par2</code>.</p>"},{"location":"Programmer_Guide/ParticleSystem/Class%3AParticles/Description/","title":"Class: Particles","text":""},{"location":"Programmer_Guide/ParticleSystem/Class%3AParticles/Description/#introduction","title":"Introduction","text":"<p>This class handles creation of particle objects and their attributes</p> <p>Particle objects are instances of the <code>ParSim::Particle</code> class.  Each <code>Particle</code> object has attributes like position variables \\((x, y)\\), velocity components \\((vx,vy)\\) etc.</p>"},{"location":"Programmer_Guide/ParticleSystem/Class%3AParticles/Description/#physical-attributes","title":"Physical Attributes","text":"<p>All the general purpose attributes and their physical essence is listed in the following table.</p> Attributes Description <code>double x</code> position \\(x\\) coordinate <code>double y</code> position \\(y\\) coordinate <code>double vx</code> velocity component along \\(x\\) direction <code>double vy</code> velocity component along \\(y\\) direction <code>double alpha</code> angular position/orientation of particle <code>double omega</code> angular velocity of particle <code>double force_radial[2]</code> Components of radial force on the particle [\\(x\\)-component, \\(y\\)-component] <code>double force_tangential[2]</code> Components of tangential force on the particle [\\(x\\)-component, \\(y\\)-component] <code>double torque</code> scalar torque on particle <code>double radius</code> radius of particle <code>double vx_activity</code> Active velocity along \\(x\\) direction <code>double vy_activity</code> Active velocity along \\(x\\) direction <code>double omega_activity</code> Active angular velocity <code>double theta</code> Active translational velocity director <p>We have used forces along radial and tangential directions instead of x and y directions because in general the former are easier to calculate and code.</p> <p>Each <code>Particle</code> object also as a c++ linked-list called <code>Neighbours</code> that is meant for containing list of the particle's neighbours.</p> Attributes Description <code>std:: list&lt;int&gt; Neighbours</code> linked-list that contains a particle's neighbours' indicies <p>Some integration schemes (specifically of \\(\\mathcal{O}(dt^{2})\\) and higher order), need to have information about a particle's poistion, velocity and forces of previous time step. The following attributes are meant to store this information.</p> Attributes Description <code>double position_prev[2]</code> position \\((x,y)\\) of previous step <code>double velocity_prev[2]</code> position \\((vx,vy)\\) of previous step <code>double alpha_prev</code> orientation of previous step <code>double omega_prev</code> angular velocity of previous step <code>double force_radial_prev[2]</code> radial force components of previous step <code>double force_tangential_prev[2]</code> tangential force components of previous step <code>double torque_prev</code> torque components of previous step <p>If one requires a calculation of pressure or stress (using Irving Kirkwood formula) then <code>sigma[4]</code> is the \\(\\sigma_{ab}\\) matrix.</p> Attributes Description <code>double sigma[4]</code> \\(\\sigma_{ab}\\) matrix in Irving-Kirkwood formula"},{"location":"Programmer_Guide/ParticleSystem/Class%3AParticles/Description/#intialization","title":"Intialization","text":"<p><pre><code>ParSim::Particle::Particle()\n</code></pre> Default constructor. Initializes all attributes to <code>0</code>.</p> <p><pre><code>ParSim::Particle::Particle(double x_cor, double y_cor, double v_x, double v_y, double orientation)\n</code></pre> Parameterized constructor. Intializes with received values for <code>x</code>,<code>y</code>,<code>vx</code>,<code>vy</code> and <code>alpha</code> respectively.</p> <p><pre><code>ParSim::Particle::Particle(int N, double omega, double L)\n</code></pre> Parameterize constructor. Intializes particles on a lattice grid using <code>void ParSim::Particle::Lattice_initialize</code></p> <p><pre><code>void ParSim::Particle::Lattice_initialize(int N, double omega_act, double L)\n</code></pre> Initalizes <code>N</code> particles on a lattice grid of side-length <code>L</code>. Receives<code>omega_activity</code> as an input <code>omega_act</code>. <code>vx,vy,alpha,omega,theta</code> are randomly initialized using uniform real distributions.</p>"},{"location":"Programmer_Guide/Physics/Overview/","title":"Overview","text":""},{"location":"Programmer_Guide/Physics/Overview/#physics-of-the-simulation","title":"Physics of the simulation","text":"<p>We can evolve the particle system, (according to some dynamical equations like Newton's equations) with time by looping  through the following steps:</p> <ol> <li>Accumulate the forces on each particle: This is carried out using force calculators, which are methods of class <code>Physics</code></li> <li>Step forward one time step using a standard differential equation solver:  This is carried out using various integrators, which are methods of class <code>Physics</code></li> <li>If desired, write the state of particle system to a file (for analysis or rendering)</li> </ol> <p>The physics of the simulation is handled by classes <code>Physics</code>, <code>Langevin_Dynamics</code></p>"},{"location":"Programmer_Guide/Physics/Class%3ALD/Description/","title":"Class: Langevin_Dynamics","text":""},{"location":"Programmer_Guide/Physics/Class%3ALD/Description/#introduction","title":"Introduction","text":"<p>This class handles systems that obey Langevin Dynamics. It is kept separated from other class for ease-of-use.</p>"},{"location":"Programmer_Guide/Physics/Class%3ALD/Description/#force-calculators","title":"Force calculators","text":"<pre><code>void ParSim::Langevin_Dynamics::Neighbours_search(ParticleSystem &amp;ps)\n</code></pre> <pre><code>void ParSim::Langevin_Dynamics::Neighbours_search_PBC(ParticleSystem &amp;ps)\n</code></pre> Force calculator with WCA interaction and PBC<pre><code>void ParSim::Langevin_Dynamics::Force_NL_PBC_WCA(ParSim::ParticleSystem &amp;ps)\n</code></pre> <ol> <li>This Force Calculator uses Neighbour lists of each particle object to calculate force.</li> <li>Interaction: WCA</li> <li>Boundary: Periodic boundary conditions. </li> </ol>"},{"location":"Programmer_Guide/Physics/Class%3ALD/Description/#integrators","title":"Integrators","text":"<p>This section contains information for the integrators. </p> <ul> <li>We need a new integrator other than conventional ones that integrate the Langevin Dynamics eqautions.</li> <li>Optimal one is by Leimkuhler and Matters 2013a.</li> </ul>"},{"location":"Programmer_Guide/Physics/Class%3ALD/Description/#boaob-algorithm-lm-integrators","title":"BOAOB algorithm: LM Integrators","text":"<p>Warning</p> <p>Equations for theta evolution involve omega dependent force. BOAOB method is best for forces that are  derived from a position dependent potentianl only. We are still using the same integrator for theta.</p> <p>LM integration is carried out by the following two methods in parts</p> First Part<pre><code>void ParSim::Langevin_Dynamics::LM_Intergrator1(ParSim::ParticleSystem &amp;parsym, int step)\n</code></pre> <ol> <li>Updates \\(v(t)\\) to \\(v(t+(dt/2))\\) </li> <li>Updates \\(x(t)\\) to \\(x(t+(dt/2))\\) using \\(v(t+(dt/2))\\)</li> <li>Adds Fluctuation and Dissipation changing \\(v(t+(dt/2))\\) to \\(v'(t+(dt/2))\\)</li> <li>Updates  \\(x(t+(dt/2))\\) to \\(x(t + dt)\\) using \\(v'(t+(dt/2))\\)</li> </ol> <p>For updating \\(v'(t+(dt/2))\\) to \\(v(t+dt)\\) we need to calculate forces (that are position dependent) using \\(x(t + dt)\\); </p> Second part<pre><code>void ParSim::Langevin_Dynamics::LM_Intergrator2(ParSim::ParticleSystem &amp;parsym, int step)\n</code></pre> <ol> <li>Updates \\(v'(t+(dt/2))\\) to \\(v(t+dt)\\) using new forces \\(f(t+dt)\\)</li> </ol>"},{"location":"Programmer_Guide/Physics/Class%3ALD/Description/#evolvers","title":"Evolvers","text":"<p>Task of an Evolver is to bring together appropriate force calculators and intergrators in the correct order of execution as required by the integration scheme you are using.</p>"},{"location":"Programmer_Guide/Physics/Class%3ALD/Description/#lm-evolver","title":"LM Evolver","text":"LM evolver<pre><code>void ParSim::Langevin_Dynamics::evolve_system_LM_NL(ParticleSystem &amp;parsym, int step) {\n\n  // Update Neighbour list after every NL_tau steps\n  if (step == 0 || step % this-&gt;NL_tau == 0) {\n    Neighbours_search(parsym);\n  }\n  // LM integration: (x(t),v(t)) -- &gt; (x(t + dt),v(t + dt))\n\n  // i) Calculate force f(t) using (x(t)) --\n  Force_NL_PBC_WCA(parsym);\n\n  // ii) Update (x(t), v(t))  to (x(t+dt) , v'(t+(dt/2))\n  LM_Intergrator1(parsym, step);\n\n  // iii) Again calculate force f(t+dt) from x((t+dt))\n  Force_NL_PBC_WCA(parsym);\n\n  //  iv) Update v'(t+(dt/2)) to v(t+dt) --------\n  LM_Intergrator2(parsym, step);\n}\n</code></pre>"},{"location":"Programmer_Guide/Physics/Class%3APhysics/Description/","title":"Class: Physics","text":""},{"location":"Programmer_Guide/Physics/Class%3APhysics/Description/#introduction","title":"Introduction","text":"<p>This class is responsible for evolving the attributes of each <code>Particle</code> entity of our particle system <code>Particle System</code> object according to dynamical equations.</p>"},{"location":"Programmer_Guide/Physics/Class%3APhysics/Description/#force-calculators","title":"Force calculators","text":""},{"location":"Programmer_Guide/Physics/Class%3APhysics/Description/#particle-particle-force-calculators","title":"Particle-Particle Force calculators","text":"<pre><code>void ParSim::Physics::Force_PP(ParSim::ParticleSystem &amp;ps)\n</code></pre> <pre><code>void ParSim::Physics::Force_PP_PBC(ParSim::ParticleSystem &amp;ps)\n</code></pre> <pre><code>void ParSim::Physics::Force_PP_CRB(ParSim::ParticleSystem &amp;ps)\n</code></pre> <pre><code>void ParSim::Physics::Force_PP_CRB_WCA(ParSim::ParticleSystem &amp;ps)\n</code></pre>"},{"location":"Programmer_Guide/Physics/Class%3APhysics/Description/#neighbour-list-force-calculators","title":"Neighbour list Force calculators","text":"<pre><code>void ParSim::Physics::Neighbours_search_PBC(ParticleSystem &amp;ps)\n</code></pre> <pre><code>void ParSim::Physics::Neighbours_search(ParticleSystem &amp;ps)\n</code></pre> <pre><code>void ParSim::Physics::Force_NL_PBC(ParSim::ParticleSystem &amp;ps)\n</code></pre> <pre><code>void ParSim::Physics::Force_NL_CRB_WCA(ParSim::ParticleSystem &amp;ps)\n</code></pre>"},{"location":"Programmer_Guide/Physics/Class%3APhysics/Description/#integrators","title":"Integrators","text":"<pre><code>void ParSim::Physics::Euler_Integrator(ParSim::Particle &amp;par, int step)\n</code></pre> <pre><code>void ParSim::Physics::Vel_Verlet_Integrator(ParSim::Particle &amp;par, int step) \n</code></pre> <pre><code>void ParSim::Physics::ERM_Integrator1_sys(ParSim::ParticleSystem &amp;parsym, int step)\n</code></pre> <pre><code>void ParSim::Physics::ERM_Integrator2_sys(ParSim::ParticleSystem &amp;parsym, int step)\n</code></pre>"},{"location":"Programmer_Guide/Physics/Class%3APhysics/Description/#evolvers","title":"Evolvers","text":"<pre><code>void ParSim::Physics::evolve_system(ParticleSystem &amp;parsym, int step)\n</code></pre> <pre><code>void ParSim::Physics::evolve_system_ERM(ParticleSystem &amp;parsym, int step)\n</code></pre> <pre><code>void ParSim::Physics::evolve_system_ERM_NL(ParticleSystem &amp;parsym, int step)\n</code></pre>"},{"location":"Putting_together/Circular_boundary/","title":"Confined Gas","text":""},{"location":"Putting_together/Circular_boundary/#gas-inside-circular-walls","title":"Gas inside circular walls","text":"<p>Here we simulate a gas that is a collection of hard spheres with circular walls.</p> main()<pre><code>// 1) Creating and initializaing particle system\n\n  /*Parameters*/\n\n  int Number_of_particles = 256;\n  int Number_of_time_steps = 100000;\n  double omega = 0.0;   //no intrinsic rotation                           \n  double phi = 0.1;                            // packing fraction\n  double L = sqrt(Number_of_particles / (phi)); // Dimension of periodic box\n\n  ParSim::ParticleSystem parsym(Number_of_particles, omega, L); // create a simple system\n  ParSim::Physics Physics;\n  ParSim::Particle *const particle =\n      parsym.get_particles(); // get access to particles\n\n\n /*Setting physics parameters -- all game to be played here */\n  Physics.parameters[8] = 0.001; // time step\n  Physics.parameters[1] = 2.0;   // interaction_diameter sigma\n  Physics.parameters[2] = 10.0;  // mass\n  Physics.parameters[13] =\n      Physics.parameters[2] * (Physics.parameters[1]) *\n      (Physics.parameters[1]) / 8.0; // I = (1/8)m*(simga)^2\n\n  Physics.parameters[5] = 0.01;    // gamma_t\n\n  Physics.WCA_parameters[0] = 1.0; // WCA epsilon\n  Physics.WCA_parameters[1] =\n      Physics.parameters[1]; // WCA sigma\n\n\n  Physics.circular_wall_parameters[0] = 1.0; // WCA epsilon\n  Physics.circular_wall_parameters[1] =\n      Physics.parameters[1]; // WCA sigma\n\n  Physics.NL_skin_depth =\n      2 * Physics.parameters[1]; // 2*simga, NL_skin_depth, DeltaR\n  Physics.NL_tau = 200;          // NL_Tau, tau    \n\n  //Set other parameters you would like..\n\n// 2)Reading initial state positions\n\n  /*If desired, one can read initial state from a file*/\n\n  std::ifstream input_state(\"init_state.txt\");\n  int i = 0;\n  double temp;\n\n  if (!input_state) { // file couldn't be opened\n    std::cerr &lt;&lt; \"\\033[31mError: Init_state file could not be opened\"\n              &lt;&lt; std::endl;\n    exit(1);\n  }\n\n  while (input_state &gt;&gt; particle[i].x &gt;&gt;\n         particle[i].y) { // read particle x and y and z in temp\n    i++;\n  }\n\n  std::cout &lt;&lt; \"\\033[32mInput state read for \" &lt;&lt; i &lt;&lt; \" particles ...\"\n            &lt;&lt; std ::endl;\n\n  input_state.close();  \n\n//3) Main simulation loop--------------\n  for (int step = 0; step &lt; Number_of_time_steps; step++) {\n\n    // i) writing data of this state to file (will can be used for rendering and analysis)\n            // write the data of this state to a file\n\n    // ii)Manipulate particle positions for next iteration.\n    Physics.evolve_system_ERM_NL(parsym, step);\n  }\n</code></pre> <p>The Evolver looks like this</p> evolve_system_ERM_NL(parsym, step)<pre><code>void ParSim::Physics::evolve_system_ERM_NL(ParticleSystem &amp;parsym, int step) {\n\n  // Update Neighbour list after every 200 steps\n  if (step == 0 || step % this-&gt;NL_tau == 0) {\n    Neighbours_search(parsym);\n  }\n  // i) Calculate force (F) from positions and velocities (x,v) --\n  Force_NL_CRB_WCA(parsym); // links forces on each object\n\n  // ii) Update x,v to x', v'  ----\n  ERM_Integrator1_sys(parsym, step);\n\n  // iii) Again calculate force (F') from x',v' ------\n  Force_NL_CRB_WCA(parsym);\n\n  //  iv) Update x',v' to xnew, vnew --------\n  ERM_Integrator2_sys(parsym, step);\n}\n</code></pre> <p>Output: (as rendered in Ovito)</p>  A gas of hard particles with circular boundary"},{"location":"Putting_together/Interacting_gas/","title":"Gas in bulk","text":""},{"location":"Putting_together/Interacting_gas/#gas-with-periodic-boundaries","title":"Gas with periodic boundaries","text":"<p>Here we simulate a gas that is a collection of hard spheres with periodic boundary conditions.</p> main()<pre><code>// 1) Creating and initializaing particle system\n\n  /*Parameters*/\n\n  int Number_of_particles = 256;\n  int Number_of_time_steps = 100000;\n  double omega = 0.0;   //no intrinsic rotation                           \n  double phi = 0.1;                            // packing fraction\n  double L = sqrt(Number_of_particles / (phi)); // Dimension of periodic box\n\n  ParSim::ParticleSystem parsym(Number_of_particles, omega, L); // create a simple system\n  ParSim::Physics Physics;\n  ParSim::Particle *const particle =\n      parsym.get_particles(); // get access to particles\n\n\n /*Setting physics parameters -- all game to be played here */\n  Physics.parameters[8] = 0.001; // time step\n  Physics.parameters[1] = 2.0;   // interaction_diameter sigma\n  Physics.parameters[2] = 10.0;  // mass\n  Physics.parameters[13] =\n      Physics.parameters[2] * (Physics.parameters[1]) *\n      (Physics.parameters[1]) / 8.0; // I = (1/8)m*(simga)^2\n\n  Physics.parameters[5] = 0.01;    // gamma_t\n\n  Physics.WCA_parameters[0] = 1.0; // WCA epsilon\n  Physics.WCA_parameters[1] =\n      Physics.parameters[1]; // WCA sigma\n\n\n  Physics.NL_skin_depth =\n      2 * Physics.parameters[1]; // 2*simga, NL_skin_depth, DeltaR\n  Physics.NL_tau = 200;          // NL_Tau, tau    \n\n  //Set other parameters you would like..\n\n//2) Main simulation loop--------------\n  for (int step = 0; step &lt; Number_of_time_steps; step++) {\n\n    // i) writing data of this state to file (will can be used for rendering and analysis)\n            // write the data of this state to a file\n\n    // ii)Manipulate particle positions for next iteration.\n    Physics.evolve_system_ERM_NL(parsym, step);\n  }\n</code></pre> <p>The Evolver looks like this</p> evolve_system_ERM_NL(parsym, step)<pre><code>void ParSim::Physics::evolve_system_ERM_NL(ParticleSystem &amp;parsym, int step) {\n\n  // Update Neighbour list after every 200 steps\n  if (step == 0 || step % this-&gt;NL_tau == 0) {\n    Neighbours_search_PBC(parsym);\n  }\n  // i) Calculate force (F) from positions and velocities (x,v) --\n  Force_NL_PBC_WCA(parsym); // links forces on each object\n\n  // ii) Update x,v to x', v'  ----\n  ERM_Integrator1_sys(parsym, step);\n\n  // iii) Again calculate force (F') from x',v' ------\n  Force_NL_PBC_WCA(parsym);\n\n  //  iv) Update x',v' to xnew, vnew --------\n  ERM_Integrator2_sys(parsym, step);\n}\n</code></pre> <p>Output: (as rendered in Ovito)</p>  A gas of hard particles with periodic boundary conditions"},{"location":"Putting_together/Langevin_Dynamics/","title":"Langevin Dynamics","text":""},{"location":"Putting_together/Langevin_Dynamics/#a-system-that-obeys-langevin-dynamics","title":"A system that obeys Langevin Dynamics","text":"<p>Consider a system of <code>N</code> particles. The dynamical equation of any of these particles is given by <sup>1</sup>:</p> \\[ \\dot{\\mathbf{r}} = \\mathbf{v} = \\mathbf{p}/m \\] \\[ \\dot{\\mathbf{p}} = \\mathbf{f} - \\zeta\\mathbf{v} + \\sigma \\dot{\\mathbf{w}} \\] <p>\\(\\dot{\\mathbf{w}}\\) is Wiener Process. </p> \\[ d\\mathbf{w} = \\mathbf{w}(t+dt) = \\sqrt{t}\\mathbf{G} \\] <p>\\(\\mathbf{G}\\) is a Gaussian random variable with zero mean and unit variance.</p>"},{"location":"Putting_together/Langevin_Dynamics/#numerical-integration","title":"Numerical Integration","text":"<p>The above dynamical equations are integrated using BOAOB algorithm (Leimkuhler and Matthews (2013a)) <sup>1</sup>.</p>"},{"location":"Putting_together/Langevin_Dynamics/#code-workflow","title":"Code workflow","text":""},{"location":"Putting_together/Langevin_Dynamics/#initialize-and-parameters-set-up","title":"Initialize and Parameters set-up","text":"<p>This is how the main program file should look like</p> main()<pre><code>int Number_of_particles;\nint Number_of_time_steps;\ndouble L;        //system size \ndouble omega;   //Rotational activity\n\n//1) Initialize Particle system and Langevin Dyanmics\n ParSim::ParticleSystem parsym(Number_of_particles, omega, L); // create a simple system (using lattice init)\n ParSim::Langevin_Dynamics Langevin_Dyanmics;\n\n\n/*Setting physics parameters --  */\n  Langevin_Dyanmics.parameters[8] = 0.001; // time step\n  Langevin_Dyanmics.parameters[1] = 2.0;   // interaction_diameter sigma\n  Langevin_Dyanmics.parameters[2] = 10.0;  // mass\n  Langevin_Dyanmics.parameters[13] =\n      Langevin_Dyanmics.parameters[2] * (Langevin_Dyanmics.parameters[1]) *\n      (Langevin_Dyanmics.parameters[1]) / 8.0; // I = (1/8)m*(simga)^2\n\n  // Fluctuation-Dissipation Parameters\n  Langevin_Dyanmics.FD_parameters[0] = 100.0; // jeta_t\n  Langevin_Dyanmics.FD_parameters[1] = 100.0; // jeta_r\n  Langevin_Dyanmics.FD_parameters[2] = 1.0;   // kbt\n  Langevin_Dyanmics.FD_parameters[3] = 0.0;   // D\n //Intialize other parameters\n\n//2) Main simulation loop--------------\n  for (int step = 0; step &lt; Number_of_time_steps; step++) {\n\n    // i) writing data of this state to file (will can be used for rendering and analysis)\n\n    if (step % 200 == 0) {\n    // write the data of this state to a file\n    }\n\n    // ii) Manipulate particle positions for next iteration.\n    Langevin_Dyanmics.evolve_system_LM_NL(parsym, step);\n  }\n</code></pre>"},{"location":"Putting_together/Langevin_Dynamics/#integrators","title":"Integrators","text":"<p>Already provided integrators:</p> <pre><code>void ParSim::Langevin_Dynamics::LM_Intergrator1(ParSim::ParticleSystem &amp;parsym, int step)\nvoid ParSim::Langevin_Dynamics::LM_Intergrator2(ParSim::ParticleSystem &amp;parsym, int step)\n</code></pre>"},{"location":"Putting_together/Langevin_Dynamics/#evolver","title":"Evolver","text":"<p>Evolver will look something like this.</p> LM evolver<pre><code>void ParSim::Langevin_Dynamics::evolve_system_LM_NL(ParticleSystem &amp;parsym, int step) {\n\n  // Update Neighbour list after every NL_tau steps\n  if (step == 0 || step % this-&gt;NL_tau == 0) {\n    Neighbours_search(parsym);\n  }\n  // LM integration: (x(t),v(t)) -- &gt; (x(t + dt),v(t + dt))\n\n  // i) Calculate force f(t) using (x(t)) --\n  Force_NL_PBC_WCA(parsym);\n\n  // ii) Update (x(t), v(t))  to (x(t+dt) , v'(t+(dt/2))\n  LM_Intergrator1(parsym, step);\n\n  // iii) Again calculate force f(t+dt) from x((t+dt))\n  Force_NL_PBC_WCA(parsym);\n\n  //  iv) Update v'(t+(dt/2)) to v(t+dt) --------\n  LM_Intergrator2(parsym, step);\n}\n</code></pre> <ol> <li> <p>Michael P Allen and Dominic J Tildesley. Computer simulation of liquids. Oxford university press, 2017.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"Putting_together/Overview/","title":"Overview","text":""},{"location":"Putting_together/Overview/#putting-together","title":"Putting together","text":"<p>In this section, I will illustrate the use of this code using some particular examples.</p>"}]}